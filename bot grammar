import telebot
import json
import shelve
import requests
import time
from random import choice


class Db:
    @staticmethod
    def write_user(dictionary, user_id):
        with open('json_data', 'r', encoding='utf-8') as inp:
            list_of_dict = json.load(inp)
            list_of_dict[str(user_id)] = dictionary

            with open('json_data', 'w', encoding='utf-8') as data:
                json.dump(list_of_dict, data, indent=4, ensure_ascii=False)

    @staticmethod
    def get_user():
        with open('json_data', 'r', encoding='utf-8') as inp:
            return json.load(inp)

    @staticmethod
    def get_priority():
        with open('json_priority', 'r', encoding='utf-8') as inp:
            return json.load(inp)

    @staticmethod
    def write_priority(dictionary, user_id):
        with open('json_priority', 'r', encoding='utf-8') as inp:
            list_of_dict = json.load(inp)
            list_of_dict[str(user_id)] = dictionary

            with open('json_priority', 'w', encoding='utf-8') as data:
                json.dump(list_of_dict, data, indent=4, ensure_ascii=False)

    @staticmethod
    def get_subway(city):
        with open('json_subway', 'r', encoding='utf-8') as inp:
            return json.load(inp)[city]


class User:
    def __init__(self, message_id):
        self.quest = Db.get_user()
        self.quest[str(message_id)] = {
            'name': '',
            'event_type': [],
            'city_name': '',
            'amount': '',
            'hobby': [],
            'free': '',
            'params': {}
        }


class States:
    name = '1'
    event = '2'
    event_cross = '3'
    city = '4'
    city_cross = '5'
    amount = '6'
    amount_cross = '7'
    hobby = '8'
    hobby_cross = '9'
    is_free = '10'
    is_free_cross = '11'
    usage = '12'
    geo = '13'
    subway = '14'

    db_file = "database.db"

    @staticmethod
    def get_current_state(user_id):
        with shelve.open(States.db_file) as db:
            try:
                return db[str(user_id)]
            except KeyError:
                pass

    @staticmethod
    def set_state(user_id, value):
        with shelve.open(States.db_file) as db:
            db[str(user_id)] = value


class Priority:
    def __init__(self, message_id, params):
        self.dictionary = Db.get_priority()
        self.dictionary[str(message_id)] = requests.get('https://kudago.com/public-api/v1.4/events/', params=params).json()['results']
        self.dictionary[str(message_id)] = {
            'request': self.dictionary[str(message_id)],
            'amount': Db.get_user()[str(message_id)]['amount'],
            'priority': {i: 0 for i in range(len(self.dictionary[str(message_id)]))},
            'position': 0,
        }
        Db.write_priority(self.dictionary[str(message_id)], message_id)

    def priority_setting(self, message_id):
        u = Db.get_user()
        if len(self.dictionary[str(message_id)]['request']) > u[str(message_id)]['amount']:
            self.dictionary[str(message_id)]['position'] = 0
            for event in self.dictionary[str(message_id)]['request']:
                for key in ['event_type', 'hobby']:
                    for element in u[str(message_id)][key]:
                        if element in event['categories'] or element in event['tags']:
                            # за каждый элемент присутствующий как в авнкете так и в апи добавляем +1 по индексу этого элемента в апи запросе
                            self.dictionary[str(message_id)]['priority'][self.dictionary[str(message_id)]['position']] += 1
                self.dictionary[str(message_id)]['position'] += 1

            # сортируем словарь по значению
            self.dictionary[str(message_id)]['priority'] = sorted(self.dictionary[str(message_id)]['priority'].items(),
                                                                  key=lambda item: item[1], reverse=True)

            # выбираем amount наиболее подходящих параметров
            while len(self.dictionary[str(message_id)]['priority']) != self.dictionary[str(message_id)]['amount']:
                del (self.dictionary[str(message_id)]['priority'][len(self.dictionary[str(message_id)]['priority']) - 1])

            self.dictionary[str(message_id)]['priority'] = dict(self.dictionary[str(message_id)]['priority'])

        for i in self.dictionary[str(message_id)]['priority']:
            if self.dictionary[str(message_id)]['request'][i]['place'] is None:
                s = '{} \n\n' \
                    'Начало: {} {}\n' \
                    'Конец: {} {} \n\n' \
                    'Нет конкретного места \n\n' \
                    '{}' \
                    'Цена: {} \n\n' \
                    'Более подробную информацию можно посмотреть здесь: {}'.format(
                            self.dictionary[str(message_id)]['request'][i]['title'],
                            self.dictionary[str(message_id)]['request'][i]['dates'][
                                    len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['start_date'],
                            self.dictionary[str(message_id)]['request'][i]['dates'][
                                    len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['start_time'],
                            self.dictionary[str(message_id)]['request'][i]['dates'][
                                    len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['end_date'],
                            self.dictionary[str(message_id)]['request'][i]['dates'][
                                    len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['end_time'],
                            self.dictionary[str(message_id)]['request'][i]['description'],
                            self.dictionary[str(message_id)]['request'][i]['price'],
                            self.dictionary[str(message_id)]['request'][i]['site_url'])
            else:
                s = '{} \n\n' \
                    'Начало: {} {}\n' \
                    'Конец: {} {}\n\n' \
                    'Место проведения: {}.\n' \
                    'Метро: {}\n' \
                    'Адрес: {} \n\n' \
                    '{}' \
                    'Цена: {} \n\n' \
                    'Более подробную информацию можно посмотреть здесь: {}'.format(
                            self.dictionary[str(message_id)]['request'][i]['title'],
                            self.dictionary[str(message_id)]['request'][i]['dates'][
                                    len(self.dictionary[str(message_id)]['request'][i]['dates']) - 1]['start_date'],
                            self.dictionary[str(message_id)]['request'][i]['dates'][
                                    len(self.dictionary[str(message_id)]['request'][i]['dates']) - 1]['start_time'],
                            self.dictionary[str(message_id)]['request'][i]['dates'][
                                    len(self.dictionary[str(message_id)]['request'][i]['dates']) - 1]['end_date'],
                            self.dictionary[str(message_id)]['request'][i]['dates'][
                                    len(self.dictionary[str(message_id)]['request'][i]['dates']) - 1]['end_time'],
                            self.dictionary[str(message_id)]['request'][i]['place']['title'],
                            self.dictionary[str(message_id)]['request'][i]['place']['subway'],
                            self.dictionary[str(message_id)]['request'][i]['place']['address'],
                            self.dictionary[str(message_id)]['request'][i]['description'],
                            self.dictionary[str(message_id)]['request'][i]['price'],
                            self.dictionary[str(message_id)]['request'][i]['site_url'])

            s = s.replace('None', 'Нет данных')
            bot.send_message(message_id, s)


bot = telebot.TeleBot('534489748:AAHshR88itmKmN_5HSQZeMdZ1CY3zTz60aI')
joke = ["Подождите, шутим про Кел'Тузада",
        'Подождите, кормим программиста',
        'Подождите, пытаемся спрятаться от дедлайна']


@bot.message_handler(commands=['start'])
def questionnaire(message):
    States.set_state(message.chat.id, States.name)
    bot.send_message(message.chat.id, 'Приветсвую путник, я ботнейм, был призван в этот мир, дабы облегчить ориентацию '
                                      'в акуальных событиях москвы и Санкт-Петербурга. '
                                      'Сейчас тебе будет необходимо пройти небольшой опрос, касющийся твоих увлечений, '
                                      'далее же ты сможешь по команде получать перечень интересных '
                                      '(соответствующих твоит ответам на вопросы) событий рядом с '
                                      'твоей геолокацией/ выбранной станцией метро/ без привязи к месту.\n'
                                      'Видимо ты совсем отчаялся, раз пришел ко мне. '
                                      'Но думаю, я смогу помочь, хотя у всего есть цена. '
                                      'Ответь на несколько вопросов и мы в расчете.\n'
                                      'На каждом этапе необходимо выбрать хотя бы 1 ответ, перед тем, как пройти дальше')

    events_names = ['фестиваль',
                    'кино',
                    'выставка',
                    'концерт',
                    'встреча',
                    'туризм',
                    'шоу',
                    'спортивное мероприятие',
                    'театр',
                    'игра',
                    'вечеринка',
                    'маскарад',
                    ]
    numbers = ['5', '6', '7', '8', '9', '10']
    cities = ['Москва', 'Санкт-Петербург']
    price = ['Да', 'Нет']
    hobbies = ['музыка',
               'живопись',
               'архитектруа и дизайн',
               'современное искусство',
               'новые технологии',
               'наука',
               'кулинария'
               ]

    bot.send_message(message.chat.id, "Для начала, я бы хотел узнать, как к тебе обращаться")
    person = User(message.chat.id)

    @bot.message_handler(func=lambda message: States.get_current_state(message.chat.id) == States.name)
    def i_know_de_name(message):
        person.quest[str(message.chat.id)]['name'] = message.text
        States.set_state(message.chat.id, States.event)

        markup = telebot.types.ReplyKeyboardMarkup()
        for event in events_names:
            markup.add(event)
        markup.add('Перейти к следующему вопросу')
        bot.send_message(message.chat.id,
                         'Чтож, {}, какие события ты предпочитаешь?'.format(person.quest[str(message.chat.id)]['name']),
                         reply_markup=markup)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.event and message.text in events_names)
    def event_type(message):
        if message.text not in person.quest[str(message.chat.id)]['event_type']:
            if message.text == 'фестиваль':
                person.quest[str(message.chat.id)]['event_type'].append('festival')
            elif message.text == 'кино':
                person.quest[str(message.chat.id)]['event_type'].append('cinena')
            elif message.text == 'выставка':
                person.quest[str(message.chat.id)]['event_type'].append('exhibition')
            elif message.text == 'концерт':
                person.quest[str(message.chat.id)]['event_type'].append('concert')
            elif message.text == 'встреча':
                person.quest[str(message.chat.id)]['event_type'].append('meeting')
            elif message.text == 'туризм':
                person.quest[str(message.chat.id)]['event_type'].append('tour')
            elif message.text == 'шоу':
                person.quest[str(message.chat.id)]['event_type'].append('show')
            elif message.text == 'спортивное мероприятие':
                person.quest[str(message.chat.id)]['event_type'].append('sport')
            elif message.text == 'театр':
                person.quest[str(message.chat.id)]['event_type'].append('theatre')
            elif message.text == 'игра':
                person.quest[str(message.chat.id)]['event_type'].append('game')
            elif message.text == 'вечеринка':
                person.quest[str(message.chat.id)]['event_type'].append('party')
            elif message.text == 'маскарад':
                person.quest[str(message.chat.id)]['event_type'].append('masquerade')
        States.set_state(message.chat.id, States.event_cross)

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.event_cross and message.text == 'Перейти к следующему вопросу')
    def go_to_next(message):
        markup = telebot.types.ReplyKeyboardMarkup()
        for city in cities:
            markup.add(city)
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id, 'Теперь, я хотел бы знать, откуда судьба принесла тебя?', reply_markup=markup)
        States.set_state(message.chat.id, States.city)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.city and message.text in cities)
    def city_name(message):
        if message.text == 'Москва':
            person.quest[str(message.chat.id)]['city_name'] = 'msk'
        elif message.text == 'Санкт-Петербург':
            person.quest[str(message.chat.id)]['city_name'] = 'spb'
        States.set_state(message.chat.id, States.city_cross)

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.city_cross and message.text == 'Перейти к следующему вопросу')
    def go_to_next1(message):
        markup = telebot.types.ReplyKeyboardMarkup()
        for i in range(5, 11):
            markup.add(str(i))
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id,
                         'О скольки событиях ты бы хотел получать информацию за раз?',
                         reply_markup=markup)
        States.set_state(message.chat.id, States.amount)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.amount and message.text in numbers)
    def restriction(message):
        person.quest[str(message.chat.id)]['amount'] = int(message.text)
        States.set_state(message.chat.id, States.amount_cross)

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.amount_cross and message.text == 'Перейти к следующему вопросу')
    def go_to_next2(message):
        markup = telebot.types.ReplyKeyboardMarkup()
        for hobby in hobbies:
            markup.add(hobby)
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id, 'Также мне необходимо знать о твоих увлечениях', reply_markup=markup)
        States.set_state(message.chat.id, States.hobby)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.hobby and message.text in hobbies)
    def hobby(message):
        if message.text not in person.quest[str(message.chat.id)]['hobby']:
            person.quest[str(message.chat.id)]['hobby'].append(message.text)
        States.set_state(message.chat.id, States.hobby_cross)

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.hobby_cross and message.text == 'Перейти к следующему вопросу')
    def go_to_next3(message):
        markup = telebot.types.ReplyKeyboardMarkup()
        for p in price:
            markup.add(p)
        markup.add('Закончить опрос')

        bot.send_message(message.chat.id, 'И напоследок, хотел бы ты видеть платные события?', reply_markup=markup)
        States.set_state(message.chat.id, States.is_free)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.is_free and message.text in price)
    def cost(message):
        if message.text == 'Да':
            person.quest[str(message.chat.id)]['free'] = 0
        elif message.text == 'Нет':
            person.quest[str(message.chat.id)]['free'] = 1
        States.set_state(message.chat.id, States.is_free_cross)

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.is_free_cross and message.text == 'Закончить опрос')
    def end(message):
        Db.write_user(person.quest[str(message.chat.id)], message.chat.id)

        markup = telebot.types.ReplyKeyboardRemove()
        bot.send_message(message.chat.id,
                         'Благодарю, ты ответил на все мои вопросы \n'
                         'Если захочешь что-то изменить, еще раз активируй команду /start \n'
                         'В том же случае, если ты забыл зачем я в этом мире или хочешь узнать доступные команды, '
                         'напиши /help',
                         reply_markup=markup)
        States.set_state(message.chat.id, States.usage)


@bot.message_handler(commands=['help'])
def help(message):
    bot.send_message(message.chat.id, 'Я призван облегчить ориентацию в акуальных событиях москвы и Санкт-Петербурга. '
                                      'По предоставлненным ниже командам ты можешь получить информацию о интересных '
                                      '(на основании заполненной анкеты) событиях рядом с '
                                      'твоей геолокацией/ выбранной станцией метро/ без привязи к месту.\n\n'
                                      'Список доступных команд:\n'
                                      '/start - Заполнение или перезаполнение анкеты\n'
                                      '/subway - Подборка интересующих вас событий рядом с указанной станцией метро \n'
                                      '/geo - Интересные события недалеко от вашего местоположения\n'
                                      '/general - События всего города, наиболее соответствующие вашим интересам')


@bot.message_handler(commands=['geo'], func=lambda message: States.get_current_state(message.chat.id) == States.usage)
def geolocation(message):
    States.set_state(message.chat.id, States.geo)
    keyboard = telebot.types.ReplyKeyboardMarkup()
    button_geo = telebot.types.KeyboardButton(text="Отправить геолокацию", request_location=True)
    keyboard.add(button_geo)
    bot.send_message(message.chat.id,
                     "Для начала, было бы неплохо поделиться месторасположением(нет, я и не думал следить за вами)",
                     reply_markup=keyboard)

    @bot.message_handler(content_types=['location'], func=lambda message: States.get_current_state(message.chat.id) == States.geo)
    def coordinates(message):
        States.set_state(message.chat.id, States.usage)

        markup = telebot.types.ReplyKeyboardRemove()
        u = Db.get_user()

        u[str(message.chat.id)]['params'] = {
            'page_size': '100',
            'fields': 'id,dates,title,short_title,slug,place,description,body_text,location,categories,tagline,'
                      'age_restriction,price,is_free,site_url,tags,participants',
            'expand': 'place,location,dates',
            'text_format': 'plain',
            'actual_since': time.time() - 86400 * 7,
            'location': u[str(message.chat.id)]['city_name'],
            'is_free': u[str(message.chat.id)]['free'],
            'lon': message.location.longitude,
            'lat': message.location.latitude,
            'radius': 4000
        }

        bot.send_message(message.chat.id, choice(joke), reply_markup=markup)

        p = Priority(message.chat.id, u[str(message.chat.id)]['params'])

        if len(p.dictionary[str(message.chat.id)]['request']) == 0:
            bot.send_message(message.chat.id, 'Простите, в радиусе 4 км от вас нет событий', reply_markup=markup)
        else:
            p.priority_setting(message.chat.id)


@bot.message_handler(commands=['subway'], func=lambda message: States.get_current_state(message.chat.id) == States.usage)
def subway(message):
    States.set_state(message.chat.id, States.subway)
    bot.send_message(message.chat.id, 'Введи станцию метро, рядом с которой хочешь увидеть события')

    @bot.message_handler(func=lambda message: States.get_current_state(message.chat.id) == States.subway)
    def metro(message):
        u = Db.get_user()
        sw = Db.get_subway(u[str(message.chat.id)]['city_name'])
        if message.text in sw:
            u[str(message.chat.id)]['params'] = {
                    'page_size': '100',
                    'fields': 'id,dates,title,short_title,slug,place,description,body_text,location,categories,tagline,'
                              'age_restriction,price,is_free,site_url,tags,participants',
                    'expand': 'place,location,dates',
                    'text_format': 'plain',
                    'actual_since': time.time() - 86400 * 7,
                    'location': u[str(message.chat.id)]['city_name'],
                    'is_free': u[str(message.chat.id)]['free'],
                    'lon': sw[message.text]['lon'],
                    'lat': sw[message.text]['lat'],
                    'radius': 2500
                }

            bot.send_message(message.chat.id, choice(joke))

            p = Priority(message.chat.id, u[str(message.chat.id)]['params'])

            if len(p.dictionary[str(message.chat.id)]['request']) == 0:
                bot.send_message(message.chat.id, 'Простите, в радиусе 2.5 км от станции метро нет событий')
            else:
                p.priority_setting(message.chat.id)

            States.set_state(message.chat.id, States.usage)

        else:
            bot.send_message(message.chat.id, 'Видимо, вы допустили ошибку в назвинии. Попробуйте еще раз')


@bot.message_handler(commands=['general'], func=lambda message: States.get_current_state(message.chat.id) == States.usage)
def general(message):
    u = Db.get_user()

    u[str(message.chat.id)]['params'] = {
        'page_size': '100',
        'fields': 'id,dates,title,short_title,slug,place,description,body_text,location,categories,tagline,'
                  'age_restriction,price,is_free,site_url,tags,participants',
        'expand': 'place,location,dates',
        'text_format': 'plain',
        'actual_since': time.time() - 86400 * 7,
        'location': u[str(message.chat.id)]['city_name'],
        'is_free': u[str(message.chat.id)]['free']
    }

    bot.send_message(message.chat.id, choice(joke))

    p = Priority(message.chat.id, u[str(message.chat.id)]['params'])
    p.priority_setting(message.chat.id)


if __name__ == '__main__':
    bot.polling(none_stop=True, timeout=100)
