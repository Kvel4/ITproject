import telebot
import json
import shelve
import config
import requests
import time


class db():
    def write_user(dict, user_id):
        with open('json_data', 'r', encoding='utf-8') as inp:
            list_of_dict = json.load(inp)
            list_of_dict[str(user_id)] = dict

            with open('json_data', 'w', encoding='utf-8') as data:
                json.dump(list_of_dict, data, indent=4, ensure_ascii=False)

    def get_user(self):
        with open('json_data', 'r', encoding='utf-8') as inp:
            return json.load(inp)

    def get_priority(self):
        with open('json_priority', 'r', encoding='utf-8') as inp:
            return json.load(inp)

    def write_priority(dict, user_id):
        with open('json_priority', 'r', encoding='utf-8') as inp:
            list_of_dict = json.load(inp)
            list_of_dict[str(user_id)] = dict

            with open('json_priority', 'w', encoding='utf-8') as data:
                json.dump(list_of_dict, data, indent=4, ensure_ascii=False)


class user(dict):
    def __init__(self, message_id):
        self.quest = db.get_user(1)
        self.quest[str(message_id)] = {
            'name': '',
            'event_type': [],
            'city_name': '',
            'age_restriction': '',
            'hobby': []
            }


class states():
    start = '0'
    name = '1'
    event = '2'
    city = '3'
    amount = '4'
    hobby = '5'
    isfree = '6'
    usage = '7'

    def get_current_state(user_id):
        with shelve.open(config.db_file) as db:
            try:
                return db[str(user_id)]
            except KeyError:  # Если такого ключа почему-то не оказалось
                pass  # значение по умолчанию - начало диалога

    # Сохраняем текущее «состояние» пользователя в нашу базу
    def set_state(user_id, value):
        with shelve.open(config.db_file) as db:
            try:
                db[str(user_id)] = value
                return True
            except:
                return -1


class priority(dict):
    def __init__(self, message_id, params):
        self.dictionary = db.get_priority(1)
        self.dictionary[str(message_id)] = {
            'request': requests.get('https://kudago.com/public-api/v1.4/events/', params=params).json()['results'],
            'amount': db.get_user(1)[str(message_id)]['amount'],
            'priority': {i: 0 for i in range(100)},
            'position': 0,
        }
        db.write_priority(self.dictionary[str(message_id)], message_id)


bot = telebot.TeleBot('534489748:AAHshR88itmKmN_5HSQZeMdZ1CY3zTz60aI')


@bot.message_handler(commands=['start'])
def questionary(message):
    bot.send_message(message.chat.id, 'Приветствую вас, о величайший лорд тьмы. '
                                      'Для того чтобы выполнить свою роль, мне необходимо узнать о ваших предпочтениях.'
                                      ' Надеюсь ваше высочесто соизволит ответить на несколько вопросов')

    events_names = ['фестиваль',
                    'кино',
                    'выставка',
                    'концерт',
                    'встреча',
                    'туризм',
                    'шоу',
                    'спортивное мероприятие',
                    'театр',
                    'игра',
                    'вечеринка',
                    'маскарад',
                    ]
    numbers = ['5', '6', '7', '8', '9', '10']
    cities = ['Москва', 'Санкт-Петербург']
    price = ['Да', 'Нет']
    hobbies = ['музыка',
               'живопись',
               'архитектруа и дизайн',
               'современное искусство',
               'новые технологии',
               'наука',
               'кулинария'
               ]

    bot.send_message(message.chat.id, "Как я могу к вам обращаться?")
    states.set_state(message.chat.id, states.name)
    person = user(message.chat.id)

    @bot.message_handler(func= lambda message: states.get_current_state(message.chat.id) == states.name)
    def i_know_de_name(message):
        person.quest[str(message.chat.id)]['name'] = message.text
        states.set_state(message.chat.id, states.event)

        markup = telebot.types.ReplyKeyboardMarkup()
        for event in events_names:
            markup.add(event)
        markup.add('Перейти к следующему вопросу')
        bot.send_message(message.chat.id,
                         ' Для начала давайте выясним какой тип ивентов вы предпочитаете(можно указать несколько)',
                         reply_markup=markup)

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.event and message.text in events_names)
    def event_type(message):
        if message.text not in person.quest[str(message.chat.id)]['event_type']:
            if message.text == 'фестиваль':
                person.quest[str(message.chat.id)]['event_type'].append('festival')
            elif message.text == 'кино':
                person.quest[str(message.chat.id)]['event_type'].append('cinena')
            elif message.text == 'выставка':
                person.quest[str(message.chat.id)]['event_type'].append('exhibition')
            elif message.text == 'концерт':
                person.quest[str(message.chat.id)]['event_type'].append('concert')
            elif message.text == 'встреча':
                person.quest[str(message.chat.id)]['event_type'].append('meeting')
            elif message.text == 'туризм':
                person.quest[str(message.chat.id)]['event_type'].append('tour')
            elif message.text == 'шоу':
                person.quest[str(message.chat.id)]['event_type'].append('show')
            elif message.text == 'спортивное мероприятие':
                person.quest[str(message.chat.id)]['event_type'].append('sport')
            elif message.text == 'театр':
                person.quest[str(message.chat.id)]['event_type'].append('theatre')
            elif message.text == 'игра':
                person.quest[str(message.chat.id)]['event_type'].append('game')
            elif message.text == 'вечеринка':
                person.quest[str(message.chat.id)]['event_type'].append('party')
            elif message.text == 'маскарад':
                person.quest[str(message.chat.id)]['event_type'].append('masquerade')

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.event and message.text == 'Перейти к следующему вопросу')
    def go_to_next(message):
        states.set_state(message.chat.id, states.city)

        markup = telebot.types.ReplyKeyboardMarkup()
        for city in cities:
            markup.add(city)
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id, 'Теперь выберите город', reply_markup=markup)

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.city and message.text in cities)
    def city_name(message):
        if message.text == 'Москва':
            person.quest[str(message.chat.id)]['city_name'] = 'msk'
        elif message.text == 'Санкт-Петербург':
            person.quest[str(message.chat.id)]['city_name'] = 'spb'

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.city and message.text == 'Перейти к следующему вопросу')
    def go_to_next1(message):
        states.set_state(message.chat.id, states.amount)

        markup = telebot.types.ReplyKeyboardMarkup()
        for i in range(5,11):
            markup.add(str(i))
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id,
                         'Сколько новостей вы бы хотели видеть в выдачи?(введите число от 5 до 10)',
                         reply_markup=markup)

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.amount and message.text in numbers)
    def restriction(message):
        person.quest[str(message.chat.id)]['amount'] = int(message.text)

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.amount and message.text == 'Перейти к следующему вопросу')
    def go_to_next2(message):
        states.set_state(message.chat.id, states.hobby)

        markup = telebot.types.ReplyKeyboardMarkup()
        for hobby in hobbies:
            markup.add(hobby)
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id, 'Укажите ваши увлечения', reply_markup=markup)

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.hobby and message.text in hobbies)
    def hobby(message):
        if message.text not in person.quest[str(message.chat.id)]['hobby']:
            person.quest[str(message.chat.id)]['hobby'].append(message.text)

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.hobby and message.text == 'Перейти к следующему вопросу')
    def go_to_next3(message):
        states.set_state(message.chat.id, states.isfree)

        markup = telebot.types.ReplyKeyboardMarkup()
        for p in price:
            markup.add(p)
        markup.add('Закончить опрос')

        bot.send_message(message.chat.id, 'Желаете ли вы видеть только бесплатные события', reply_markup=markup)

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.isfree and message.text in price)
    def cost(message):
        if message.text == 'Да':
            person.quest[str(message.chat.id)]['free'] = 1
        elif message.text == 'Нет':
            person.quest[str(message.chat.id)]['free'] = 0

    @bot.message_handler(func=lambda message: states.get_current_state(message.chat.id) == states.isfree and message.text == 'Закончить опрос')
    def end(message):
        db.write_user(person.quest[str(message.chat.id)], message.chat.id)
        states.set_state(message.chat.id, states.usage)
        
        markup = telebot.types.ReplyKeyboardRemove()
        bot.send_message(message.chat.id,
                         'Спасибо, анкета составлена.'
                         ' Если вы заходите что-то изменить в ней еще раз активируйте команду /start',
                         reply_markup=markup)


@bot.message_handler(commands=['help'])
def help(message):
    bot.send_message(message.chat.id, 'Список доступных команд:\n'
                                      '/start - Заполнение или перезаполнение анкеты\n'
                                      '/subway - \n'
                                      '/geo - \n'
                                      '/general -')


@bot.message_handler(commands=['geo'])
def geolocation(message):
    # Эти параметры для клавиатуры необязательны, просто для удобства
    keyboard = telebot.types.ReplyKeyboardMarkup()
    button_geo = telebot.types.KeyboardButton(text="Отправить местоположение", request_location=True)
    keyboard.add(button_geo)
    bot.send_message(message.chat.id,
                     "Отправь мне свое местоположение, жалкий человечишка!",
                     reply_markup=keyboard)


@bot.message_handler(commands=['subway'])
def subway(message):
    bot.send_message(message.chat.id, 'Введи станцию метро, рядом с которой хочешь увидеть события')


@bot.message_handler(commands=['general'])
def general(message):
    u = db.get_user(1)

    params = {
        'page_size': '100',
        'fields': 'id,dates,title,short_title,slug,place,description,body_text,location,categories,tagline,'
                  'age_restriction,price,is_free,site_url,tags,participants',
        'expand': 'place,location,dates',
        'text_format': 'plain',
        'actual_since': time.time() - 86400*7,
        'location': u[str(message.chat.id)]['city_name'],
        'is_free': u[str(message.chat.id)]['free']
    }

    p = priority(message.chat.id, params)

    p.dictionary[str(message.chat.id)]['position'] = 0
    for event in p.dictionary[str(message.chat.id)]['request']:
        for key in ['event_type', 'hobby']:
            for element in u[str(message.chat.id)][key]:
                if element in event['categories'] or element in event['tags']:
                    # за каждый элемент присутствующий как в авнкете так и в апи добавляем +1 по индексу этого элемента в апи запросе
                    p.dictionary[str(message.chat.id)]['priority'][p.dictionary[str(message.chat.id)]['position']] += 1
        p.dictionary[str(message.chat.id)]['position'] += 1

    #сортируем словарь по значению
    p.dictionary[str(message.chat.id)]['priority'] = sorted(p.dictionary[str(message.chat.id)]['priority'].items(),
                                                            key=lambda item: item[1], reverse=True)

    #выбираем amount наиболее подходящих параметров
    while len(p.dictionary[str(message.chat.id)]['priority']) != p.dictionary[str(message.chat.id)]['amount']:
        del(p.dictionary[str(message.chat.id)]['priority'][len(p.dictionary[str(message.chat.id)]['priority'])-1])

    for i in p.dictionary[str(message.chat.id)]['priority']:
        if p.dictionary[str(message.chat.id)]['request'][i[0]]['place'] is not None:
            s = '{} \n\n' \
                'Начало: {} {}\n' \
                'Конец: {} {}\n\n' \
                'Место проведения: {}.\n' \
                'Метро: {}\n' \
                'Адрес: {} \n\n' \
                '{}' \
                'Цена: {} \n\n' \
                'Более подробную информацию можно посмотреть здесь: {}'.format(
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['title'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['dates'][0]['start_date'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['dates'][0]['start_time'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['dates'][0]['end_date'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['dates'][0]['end_time'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['place']['title'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['place']['subway'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['place']['address'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['description'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['price'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['site_url'])
        else:
            s = '{} \n\n' \
                'Начало: {} {}\n' \
                'Конец: {} {} \n\n' \
                'Нет конкретного места \n\n'\
                '{}' \
                'Цена: {} \n\n' \
                'Более подробную информацию можно посмотреть здесь: {}'.format(
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['title'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['dates'][0]['start_date'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['dates'][0]['start_time'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['dates'][0]['end_date'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['dates'][0]['end_time'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['description'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['price'],
                                p.dictionary[str(message.chat.id)]['request'][i[0]]['site_url'])

        s = s.replace('None', 'Нет данных')
        bot.send_message(message.chat.id, s)


if __name__ == '__main__':
    bot.polling(none_stop=True)
