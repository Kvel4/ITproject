import telebot
import json
import shelve
import requests
import time
import config


class Db:
    def write_user(dict, user_id):
        with open('json_data', 'r', encoding='utf-8') as inp:
            list_of_dict = json.load(inp)
            list_of_dict[str(user_id)] = dict

            with open('json_data', 'w', encoding='utf-8') as data:
                json.dump(list_of_dict, data, indent=4, ensure_ascii=False)

    def get_user(self):
        with open('json_data', 'r', encoding='utf-8') as inp:
            return json.load(inp)

    def get_priority(self):
        with open('json_priority', 'r', encoding='utf-8') as inp:
            return json.load(inp)

    def write_priority(dict, user_id):
        with open('json_priority', 'r', encoding='utf-8') as inp:
            list_of_dict = json.load(inp)
            list_of_dict[str(user_id)] = dict

            with open('json_priority', 'w', encoding='utf-8') as data:
                json.dump(list_of_dict, data, indent=4, ensure_ascii=False)


class User:
    def __init__(self, message_id):
        self.quest = Db.get_user(1)
        self.quest[str(message_id)] = {
            'name': '',
            'event_type': [],
            'city_name': '',
            'age_restriction': '',
            'hobby': []
        }


class States:
    start = '0'
    name = '1'
    event = '2'
    city = '3'
    amount = '4'
    hobby = '5'
    isfree = '6'
    usage = '7'
    geo = '8'

    def get_current_state(user_id):
        with shelve.open(config.db_file) as db:
            try:
                return db[str(user_id)]
            except KeyError:  # Если такого ключа почему-то не оказалось
                pass  # значение по умолчанию - начало диалога

    # Сохраняем текущее «состояние» пользователя в нашу базу
    def set_state(user_id, value):
        with shelve.open(config.db_file) as db:
            try:
                db[str(user_id)] = value
                return True
            except:
                return -1


class Priority:
    def __init__(self, message_id, params):
        self.dictionary = Db.get_priority(1)
        self.dictionary[str(message_id)] = {
            'request': requests.get('https://kudago.com/public-api/v1.4/events/', params=params).json()['results'],
            'amount': Db.get_user(1)[str(message_id)]['amount'],
            'priority': {i: 0 for i in range(100)},
            'position': 0,
        }
        Db.write_priority(self.dictionary[str(message_id)], message_id)

    def priority_setting(self, message_id):
        u = Db.get_user(1)

        self.dictionary[str(message_id)]['position'] = 0
        for event in self.dictionary[str(message_id)]['request']:
            for key in ['event_type', 'hobby']:
                for element in u[str(message_id)][key]:
                    if element in event['categories'] or element in event['tags']:
                        # за каждый элемент присутствующий как в авнкете так и в апи добавляем +1 по индексу этого элемента в апи запросе
                        self.dictionary[str(message_id)]['priority'][self.dictionary[str(message_id)]['position']] += 1
            self.dictionary[str(message_id)]['position'] += 1

        # сортируем словарь по значению
        self.dictionary[str(message_id)]['priority'] = sorted(self.dictionary[str(message_id)]['priority'].items(),
                                                              key=lambda item: item[1], reverse=True)

        # выбираем amount наиболее подходящих параметров
        while len(self.dictionary[str(message_id)]['priority']) != self.dictionary[str(message_id)]['amount']:
            del (self.dictionary[str(message_id)]['priority'][len(self.dictionary[str(message_id)]['priority']) - 1])

        for i in self.dictionary[str(message_id)]['priority']:
            if self.dictionary[str(message_id)]['request'][i[0]]['place'] is None:
                s = '{} \n\n' \
                    'Начало: {} {}\n' \
                    'Конец: {} {} \n\n' \
                    'Нет конкретного места \n\n' \
                    '{}' \
                    'Цена: {} \n\n' \
                    'Более подробную информацию можно посмотреть здесь: {}'.format(
                    self.dictionary[str(message_id)]['request'][i[0]]['title'],
                    self.dictionary[str(message_id)]['request'][i[0]]['dates'][
                        len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['start_date'],
                    self.dictionary[str(message_id)]['request'][i[0]]['dates'][
                        len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['start_time'],
                    self.dictionary[str(message_id)]['request'][i[0]]['dates'][
                        len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['end_date'],
                    self.dictionary[str(message_id)]['request'][i[0]]['dates'][
                        len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['end_time'],
                    self.dictionary[str(message_id)]['request'][i[0]]['description'],
                    self.dictionary[str(message_id)]['request'][i[0]]['price'],
                    self.dictionary[str(message_id)]['request'][i[0]]['site_url'])
            else:
                s = '{} \n\n' \
                    'Начало: {} {}\n' \
                    'Конец: {} {}\n\n' \
                    'Место проведения: {}.\n' \
                    'Метро: {}\n' \
                    'Адрес: {} \n\n' \
                    '{}' \
                    'Цена: {} \n\n' \
                    'Более подробную информацию можно посмотреть здесь: {}'.format(
                    self.dictionary[str(message_id)]['request'][i[0]]['title'],
                    self.dictionary[str(message_id)]['request'][i[0]]['dates'][
                        len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['start_date'],
                    self.dictionary[str(message_id)]['request'][i[0]]['dates'][
                        len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['start_time'],
                    self.dictionary[str(message_id)]['request'][i[0]]['dates'][
                        len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['end_date'],
                    self.dictionary[str(message_id)]['request'][i[0]]['dates'][
                        len(self.dictionary[str(message_id)]['request'][i[0]]['dates']) - 1]['end_time'],
                    self.dictionary[str(message_id)]['request'][i[0]]['place']['title'],
                    self.dictionary[str(message_id)]['request'][i[0]]['place']['subway'],
                    self.dictionary[str(message_id)]['request'][i[0]]['place']['address'],
                    self.dictionary[str(message_id)]['request'][i[0]]['description'],
                    self.dictionary[str(message_id)]['request'][i[0]]['price'],
                    self.dictionary[str(message_id)]['request'][i[0]]['site_url'])

            s = s.replace('None', 'Нет данных')
            bot.send_message(message_id, s)

bot = telebot.TeleBot('534489748:AAHshR88itmKmN_5HSQZeMdZ1CY3zTz60aI')


@bot.message_handler(commands=['start'])
def questionary(message):
    bot.send_message(message.chat.id, 'Приветствую вас, о величайший лорд тьмы. '
                                      'Для того чтобы выполнить свою роль, мне необходимо узнать о ваших предпочтениях.'
                                      ' Надеюсь ваше высочесто соизволит ответить на несколько вопросов')

    events_names = ['фестиваль',
                    'кино',
                    'выставка',
                    'концерт',
                    'встреча',
                    'туризм',
                    'шоу',
                    'спортивное мероприятие',
                    'театр',
                    'игра',
                    'вечеринка',
                    'маскарад',
                    ]
    numbers = ['5', '6', '7', '8', '9', '10']
    cities = ['Москва', 'Санкт-Петербург']
    price = ['Да', 'Нет']
    hobbies = ['музыка',
               'живопись',
               'архитектруа и дизайн',
               'современное искусство',
               'новые технологии',
               'наука',
               'кулинария'
               ]

    bot.send_message(message.chat.id, "Как я могу к вам обращаться?")
    States.set_state(message.chat.id, States.name)
    person = User(message.chat.id)

    @bot.message_handler(func=lambda message: States.get_current_state(message.chat.id) == States.name)
    def i_know_de_name(message):
        person.quest[str(message.chat.id)]['name'] = message.text
        States.set_state(message.chat.id, States.event)

        markup = telebot.types.ReplyKeyboardMarkup()
        for event in events_names:
            markup.add(event)
        markup.add('Перейти к следующему вопросу')
        bot.send_message(message.chat.id,
                         ' Для начала давайте выясним какой тип ивентов вы предпочитаете(можно указать несколько)',
                         reply_markup=markup)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.event and message.text in events_names)
    def event_type(message):
        if message.text not in person.quest[str(message.chat.id)]['event_type']:
            if message.text == 'фестиваль':
                person.quest[str(message.chat.id)]['event_type'].append('festival')
            elif message.text == 'кино':
                person.quest[str(message.chat.id)]['event_type'].append('cinena')
            elif message.text == 'выставка':
                person.quest[str(message.chat.id)]['event_type'].append('exhibition')
            elif message.text == 'концерт':
                person.quest[str(message.chat.id)]['event_type'].append('concert')
            elif message.text == 'встреча':
                person.quest[str(message.chat.id)]['event_type'].append('meeting')
            elif message.text == 'туризм':
                person.quest[str(message.chat.id)]['event_type'].append('tour')
            elif message.text == 'шоу':
                person.quest[str(message.chat.id)]['event_type'].append('show')
            elif message.text == 'спортивное мероприятие':
                person.quest[str(message.chat.id)]['event_type'].append('sport')
            elif message.text == 'театр':
                person.quest[str(message.chat.id)]['event_type'].append('theatre')
            elif message.text == 'игра':
                person.quest[str(message.chat.id)]['event_type'].append('game')
            elif message.text == 'вечеринка':
                person.quest[str(message.chat.id)]['event_type'].append('party')
            elif message.text == 'маскарад':
                person.quest[str(message.chat.id)]['event_type'].append('masquerade')

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.event and message.text == 'Перейти к следующему вопросу')
    def go_to_next(message):
        States.set_state(message.chat.id, States.city)

        markup = telebot.types.ReplyKeyboardMarkup()
        for city in cities:
            markup.add(city)
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id, 'Теперь выберите город', reply_markup=markup)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.city and message.text in cities)
    def city_name(message):
        if message.text == 'Москва':
            person.quest[str(message.chat.id)]['city_name'] = 'msk'
        elif message.text == 'Санкт-Петербург':
            person.quest[str(message.chat.id)]['city_name'] = 'spb'

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.city and message.text == 'Перейти к следующему вопросу')
    def go_to_next1(message):
        States.set_state(message.chat.id, States.amount)

        markup = telebot.types.ReplyKeyboardMarkup()
        for i in range(5, 11):
            markup.add(str(i))
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id,
                         'Сколько новостей вы бы хотели видеть в выдачи?(введите число от 5 до 10)',
                         reply_markup=markup)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.amount and message.text in numbers)
    def restriction(message):
        person.quest[str(message.chat.id)]['amount'] = int(message.text)

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.amount and message.text == 'Перейти к следующему вопросу')
    def go_to_next2(message):
        States.set_state(message.chat.id, States.hobby)

        markup = telebot.types.ReplyKeyboardMarkup()
        for hobby in hobbies:
            markup.add(hobby)
        markup.add('Перейти к следующему вопросу')

        bot.send_message(message.chat.id, 'Укажите ваши увлечения', reply_markup=markup)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.hobby and message.text in hobbies)
    def hobby(message):
        if message.text not in person.quest[str(message.chat.id)]['hobby']:
            person.quest[str(message.chat.id)]['hobby'].append(message.text)

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.hobby and message.text == 'Перейти к следующему вопросу')
    def go_to_next3(message):
        States.set_state(message.chat.id, States.isfree)

        markup = telebot.types.ReplyKeyboardMarkup()
        for p in price:
            markup.add(p)
        markup.add('Закончить опрос')

        bot.send_message(message.chat.id, 'Желаете ли вы видеть только бесплатные события', reply_markup=markup)

    @bot.message_handler(
        func=lambda message: States.get_current_state(message.chat.id) == States.isfree and message.text in price)
    def cost(message):
        if message.text == 'Да':
            person.quest[str(message.chat.id)]['free'] = 1
        elif message.text == 'Нет':
            person.quest[str(message.chat.id)]['free'] = 0

    @bot.message_handler(func=lambda message: States.get_current_state(
        message.chat.id) == States.isfree and message.text == 'Закончить опрос')
    def end(message):
        Db.write_user(person.quest[str(message.chat.id)], message.chat.id)
        States.set_state(message.chat.id, States.usage)

        markup = telebot.types.ReplyKeyboardRemove()
        bot.send_message(message.chat.id,
                         'Спасибо, анкета составлена.'
                         ' Если вы заходите что-то изменить в ней еще раз активируйте команду /start',
                         reply_markup=markup)


@bot.message_handler(commands=['help'])
def help(message):
    bot.send_message(message.chat.id, 'Список доступных команд:\n'
                                      '/start - Заполнение или перезаполнение анкеты\n'
                                      '/subway - \n'
                                      '/geo - \n'
                                      '/general -')


@bot.message_handler(commands=['geo'], func=lambda message: States.get_current_state(message.chat.id) == States.usage)
def geolocation(message):
    States.set_state(message.chat.id, States.geo)

    keyboard = telebot.types.ReplyKeyboardMarkup()
    button_geo = telebot.types.KeyboardButton(text="Отправить местоположение", request_location=True)
    keyboard.add(button_geo)
    bot.send_message(message.chat.id,
                     "Отправь мне свое местоположение, жалкий человечишка!",
                     reply_markup=keyboard)
    @bot.message_handler(content_types=['location'], func=lambda message: States.get_current_state(message.chat.id) == States.geo)
    def coordinates(message):
        States.set_state(message.chat.id, States.usage)

        markup = telebot.types.ReplyKeyboardRemove()

        u = Db.get_user(1)

        params = {
            'page_size': '100',
            'fields': 'id,dates,title,short_title,slug,place,description,body_text,location,categories,tagline,'
                      'age_restriction,price,is_free,site_url,tags,participants',
            'expand': 'place,location,dates',
            'text_format': 'plain',
            'actual_since': time.time() - 86400 * 7,
            'location': u[str(message.chat.id)]['city_name'],
            'is_free': u[str(message.chat.id)]['free'],
            'lon': message.location.longitude,
            'lat': message.location.latitude,
            'radius': 4000
        }

        p = Priority(message.chat.id, params)
        if p.dictionary[str(message.chat.id)]['request'] == []:
            bot.send_message(message.chat.id, 'Простите, в радиусе 4 км от вас нет событий', reply_markup=markup)
        else:
            bot.send_message(message.chat.id, 'Подождите, кормим программиста', reply_markup=markup)
            p.priority_setting(message.chat.id)


@bot.message_handler(commands=['subway'])
def subway(message):
    bot.send_message(message.chat.id, 'Введи станцию метро, рядом с которой хочешь увидеть события')


@bot.message_handler(commands=['general'], func=lambda message: States.get_current_state(message.chat.id) == States.usage)
def general(message):
    u = Db.get_user(1)

    params = {
        'page_size': '100',
        'fields': 'id,dates,title,short_title,slug,place,description,body_text,location,categories,tagline,'
                  'age_restriction,price,is_free,site_url,tags,participants',
        'expand': 'place,location,dates',
        'text_format': 'plain',
        'actual_since': time.time() - 86400 * 7,
        'location': u[str(message.chat.id)]['city_name'],
        'is_free': u[str(message.chat.id)]['free']
    }

    p = Priority(message.chat.id, params)
    p.priority_setting(message.chat.id)


if __name__ == '__main__':
    bot.polling(none_stop=True)
